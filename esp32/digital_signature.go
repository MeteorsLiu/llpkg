package freertos

import (
	"github.com/goplus/lib/c"
	_ "unsafe"
)

const ETS_DS_IV_LEN = 16

/* Encrypted ETS data. Recommended to store in flash in this format.
 */

type EtsDsDataT struct {
	RsaLength c.Uint
	Iv        [16]c.Uint8T
	C         [1584]c.Uint8T
}
type EtsDsResultT c.Int

const (
	ETS_DS_OK              EtsDsResultT = 0
	ETS_DS_INVALID_PARAM   EtsDsResultT = 1
	ETS_DS_INVALID_KEY     EtsDsResultT = 2
	ETS_DS_INVALID_PADDING EtsDsResultT = 3
	ETS_DS_INVALID_DIGEST  EtsDsResultT = 4
)

//go:linkname EtsDsEnable C.ets_ds_enable
func EtsDsEnable()

//go:linkname EtsDsDisable C.ets_ds_disable
func EtsDsDisable()

/*
 * @brief Start signing a message (or padded message digest) using the Digital Signature peripheral
 *
 * - @param message Pointer to message (or padded digest) containing the message to sign. Should be
 *   (data->rsa_length + 1)*4 bytes long.  @param data Pointer to DS data. Can be a pointer to data
 *   in flash.
 *
 * Caller must have already called ets_ds_enable() and ets_hmac_calculate_downstream() before calling
 * this function, and is responsible for calling ets_ds_finish_sign() and then
 * ets_hmac_invalidate_downstream() afterwards.
 *
 * @return ETS_DS_OK if signature is in progress, ETS_DS_INVALID_PARAM if param is invalid,
 * EST_DS_INVALID_KEY if key or HMAC peripheral is configured incorrectly.
 */
//go:linkname EtsDsStartSign C.ets_ds_start_sign
func EtsDsStartSign(message c.Pointer, data *EtsDsDataT) EtsDsResultT

/*
 * @brief Returns true if the DS peripheral is busy following a call to ets_ds_start_sign()
 *
 * A result of false indicates that a call to ets_ds_finish_sign() will not block.
 *
 * Only valid if ets_ds_enable() has been called.
 */
//go:linkname EtsDsIsBusy C.ets_ds_is_busy
func EtsDsIsBusy() bool

/* @brief Finish signing a message using the Digital Signature peripheral
 *
 * Must be called after ets_ds_start_sign(). Can use ets_ds_busy() to wait until
 * peripheral is no longer busy.
 *
 * - @param signature Pointer to buffer to contain the signature. Should be
 *   (data->rsa_length + 1)*4 bytes long.
 * - @param data Should match the 'data' parameter passed to ets_ds_start_sign()
 *
 * @param ETS_DS_OK if signing succeeded, ETS_DS_INVALID_PARAM if param is invalid,
 * ETS_DS_INVALID_DIGEST or ETS_DS_INVALID_PADDING if there is a problem with the
 * encrypted data digest or padding bytes (in case of ETS_DS_INVALID_PADDING, a
 * digest is produced anyhow.)
 */
//go:linkname EtsDsFinishSign C.ets_ds_finish_sign
func EtsDsFinishSign(signature c.Pointer, data *EtsDsDataT) EtsDsResultT

/*
Plaintext parameters used by Digital Signature.

	Not used for signing with DS peripheral, but can be encrypted
	in-device by calling ets_ds_encrypt_params()
*/
type EtsDsPDataT struct {
	Y      [128]c.Uint32T
	M      [128]c.Uint32T
	Rb     [128]c.Uint32T
	MPrime c.Uint32T
	Length c.Uint32T
}
type EtsDsKeyT c.Int

const (
	ETS_DS_KEY_HMAC EtsDsKeyT = 0
	ETS_DS_KEY_AES  EtsDsKeyT = 1
)

/* @brief Encrypt DS parameters suitable for storing and later use with DS peripheral
 *
 * @param data Output buffer to store encrypted data, suitable for later use generating signatures.
 * @param iv Pointer to 16 byte IV buffer, will be copied into 'data'. Should be randomly generated bytes each time.
 * @param p_data Pointer to input plaintext key data. The expectation is this data will be deleted after this process is done and 'data' is stored.
 * @param key Pointer to 32 bytes of key data. Type determined by key_type parameter. The expectation is the corresponding HMAC key will be stored to efuse and then permanently erased.
 * @param key_type Type of key stored in 'key' (either the AES-256 DS key, or an HMAC DS key from which the AES DS key is derived using HMAC peripheral)
 *
 * @return ETS_DS_INVALID_PARAM if any parameter is invalid, or ETS_DS_OK if 'data' is successfully generated from the input parameters.
 */
// llgo:link (*EtsDsDataT).EtsDsEncryptParams C.ets_ds_encrypt_params
func (recv_ *EtsDsDataT) EtsDsEncryptParams(iv c.Pointer, p_data *EtsDsPDataT, key c.Pointer, key_type EtsDsKeyT) EtsDsResultT {
	return 0
}
